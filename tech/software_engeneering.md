---
title: "软件架构的“术”与“道”"
date: 2022-04-17T15:17:00+08:00
description: ""
draft: true
tags: ["Software Engeneering"]
categories: ["Software"]
---

本文是我工作两年以来，对软件工程相关知识的一点学习感悟和总结，不能替代对相应软件开发知识的学习。

## 引言

这文章的标题起的有点吓人。
以我仅仅两年不到的工作经验，我对这一宏大而复杂的命题也仅仅是盲人摸象罢了，原不足以对此说三道四。
然而，过去一年多的时间里我在工作中的所读、所学大多是是即用即学的，是零碎和分散的，甚至有不少是自相矛盾的。
这些零散而矛盾的知识时常令我困惑不解，促使我找出一个框架，以容纳和关联这些零碎的知识。

作为一个理工科出身的技术人员，我的世界观深受科学思维，尤其是物理学思维的影响。
我相信这个世界上任何事情是有规律可循的，只是需要使用科学的方法总结和提炼出这些规律。
通常来讲，越底层越基本的规律也就越简单。然而无论简单还是复杂，规律本身应该是完备而自洽的，至少不是互相矛盾的。
然而软件架构中的许多原则、方法却并非如此。举几个例子：

- 互联网公司许多代码使用了所谓的“三层架构”，即一个服务代码分为Handelr、Service、Dal等层模块，层级之间由上向下逐个依赖。然而另一种非常流行的代码架构DDD（领域驱动设计），却将代码分为领域层和基础设施层，二者内部也还有较为复杂的分块。这两者是什么关系呢，是互斥还是能够融合？如果是互斥，那区分使用这两者的标准是什么？如果是共存，那二者该如何对应起来？要把一个三层架构的软件代码改写为DDD的架构，要从哪里入手？DDD架构中还需要Handler和Service层吗？这些都是我曾经面对过的现实问题。

- 罗伯特·马丁在《Clean Architecture》一书中提到过关于软件代码依赖方向的一个原则，大意为“技术应该依赖业务，技术实现代码应该依赖业务逻辑代码”；并且书中也明确提到过，“数据库”是典型的与业务无关的技术细节。按照这些原则很容易推论，数据库操作的相关代码（即Dal层）应该依赖于领域层的业务逻辑。然而现实世界里却相反，无论是公司某技术牛人对《Clean Architecture》的实践样例、还是后来组内的资深架构师们给出的建议，实际上都是领域层依赖了Dal/Infrasture层。为什么呢，是Martin错了还是公司一堆架构师都错了？亦或者二者都没错，但是某种第三方因素的影响导致了不同的设计？如果是这样，那么到底什么因素的区别导致了这一差异呢？未来设计一个新系统时，应该依据什么来判断使用哪种设计呢？

- 微服务架构和DDD的核心思想都是“水平方向的拆分”，即根据不同的业务模块拆分为不同的服务，每个服务关心自身业务域内的所有处理逻辑。然而另一种经典的设计模式CQRS却刚好相反，是按照读操作和写操作分离系统，成为单独的数据源/服务，但却并未考虑业务模块的拆解。这二者为何有不同的设计思路？实际开发时到底应该如何考虑？

软件架构中的许多原则和方法，其描述多有模糊不清或自相矛盾之处，软件工程作为一门正经的学科到底为何与传统科学相差甚远？
作为一个软件工程师到底应该如何看待和使用这些知识，如何积累自己的架构经验？
偶然间一个灵感让我想通了这些问题，这就是这篇文章的由来。
但要详细解释这背后的逻辑，仍然要从软件工程的本质谈起。

## 计算机软件的复杂性

自20世纪70年代发明以来，电子计算机系统经历了半个多世纪的发展，已经到了一个及其庞大和复杂的地步。
然而由于计算机及其衍生系统（电脑、手机、互联网）如此深入人们的日常生活，以至于大多数人，甚至大多数从业者，都没有完全意识到它的复杂性到底达到了多么惊人的地步。

计算机专业的学生大概都经历过这样的事情。过年回家，亲戚朋友问：“我的电脑坏了，能不能帮忙修一修”。大部分人可能都会回答：“我是学计算机的，不会修电脑的”。于是亲戚朋友纷纷抱怨：“学计算机的连电脑怎么都不会修，肯定学的太差了。”
类似的段子还有不少。
然而，我却未曾听说哪个机械工程或者车辆工程的学生，会被亲戚朋友问：“我家汽车坏了，你是学机械的，能不能帮忙修一修。”

我一直好奇背后的原因是什么，想来想去只能想到一个解释。大多数人即使对汽车的具体技术不了解，也知道它是很复杂的工业产品；知道它的维修是需要专业的工厂、设备和人员来进行的。然而大多数人对计算机（手机）的复杂性却没有概念，认为“这么小的东西，随便一个专业的人应该就能修吧”。
然而事实上，计算机（包括电脑和手机等）可能是人类历史上创造的最为复杂的产品之一，其复杂性远远超出一般人的想象。
如果要形容这种复杂性，可以这么考虑：
经过前两年美国的科普教育，大家都知道了芯片产业的复杂性和难度，然而即便是最复杂的CPU芯片，也不过是计算机硬件系统的一部分而已。

计算机软件是有其特殊性的。人类历史上大部分的工业门类是对自然规律的认识和利用，机械、电气、通信都是如此，更不用说生物医学和化工材料这些学科。这些学科当然也积累了及其复杂的知识，但本质上它们多受限于自然规律的制约，因此具体产品的复杂性是有一定上限的。
计算机软件则完全不同。虽然其建筑在芯片的基础上，但软件自身仅仅是逻辑的体现，只受到人类思维逻辑的约束，这导致软件的建立和更改的成本都很低。人们天然倾向于把系统复杂性推向软件而不是硬件，这导致了软件复杂度的飙升。
事实上，对于业务应用类的软件，限制其复杂性的几乎只有唯一一个因素，那就是人类思维容量的不足。一旦一个软件复杂性超越了开发人员的思维容量，这个软件也就无法再继续维护和演进了。这正是历史上许多软件项目失败的原因。

幸运的是，这并非完全无解的事情。计算机软件能够发展到今天这种如此复杂的地步，得益于软件工程的进步。软件工程为程序员们提供了一系列控制、拆分、封装复杂度的方法。在软件工程的帮助下，程序员不需要一次性面对整个软件的全部细节，只需要每次面对局部逻辑。这才使得软件在复杂性远远超过人脑思维容量的情况下，还能继续发展。

在我看来，软件架构的核心问题是复杂性管理，为此，人们创造了一系列的工具、方法和技术。

## 设计模式——软件架构的“术”


## 设计原则——软件架构的“道”


## 混沌、涌现与神经网络的启示

