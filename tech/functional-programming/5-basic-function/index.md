---
title: "函数式编程笔记（五） —— 常用函数"
# date: 2021-10-27T22:00:00+08:00
description: "我学习函数式编程的记录和思考"
draft: true
tags: ["Functional Programming"]
categories: ["Software"]
---

函数式编程中有一些常用的基本函数，这类函数通常与容器（列表）相关，经常能够简化编程。
本篇将介绍函数式编程中的几类常用的函数。

## map / foreach

map函数是一类常用的基本函数。它接受一个容器（比如list）和一个函数，并对容器中的每个值应用这个函数而得到一个新的值，所有新值组成了一个新的容器，这就是map的返回值。

举例来说，假设有一个整数的列表`[1, 2, 3, 4, 5]`，要求将列表中所有元素乘以2得到的值，我们可以这样写

```
>> map (*2) [1, 2, 3, 4, 5]
[2, 4, 6, 8, 10]
```

可以看到，相比过程式编程的for循环，这样的写法不仅简洁而且可读性更好。

由于map函数接受另一个函数作为其第一个参数，因此它是一个高阶函数。

map函数名称，来源于数学中的“映射”这一概念：它将一个集合的元素映射为另一个集合的元素。
因此，通过map函数，我们可以由一个已有的集合生成另一个新的集合。
请注意，这里对于map函数可以有两种理解。一种理解是，它将原始集合中的每一个元素通过一个变换（函数）映射到另一个元素。另一种是，map将一个旧的集合映射到一个新的集合。
这两种理解从功能上是等价的，但是函数式编程中经常采用后一种理解，这有助于提高理解的抽象层次，简化复杂性。

测试你是否完全理解了map函数有一个好办法，就是尝试写出map的类型。
现在请暂停一下，不要看答案，尝试在评论区回复写出它的类型。然后再与下面的结果作对比。

<details>
<summary>点击查看答案</summary>

map自身是一个函数，它有两个参数f,x和一个返回值y。因此根据上一章的类型表示法，map的类型为`f -> x -> y`。
继续考虑，参数x是一个包含整数的列表，因此x的实际类型为`[Integer]`。
f是一个单参数函数，它接受一个整数，返回一个整数。因此f的实际类型是`Integer -> Integer`。
map的返回值y也是一个整数列表，类型为`[Integer]`。
所以，在上述例子中，map函数的类型为
```
map :: (Integer -> Integer) -> [Integer] -> [Integer]
```
注意上面的类型表达式，由于`->`运算符是右结合的，第一个括号不可省略。这表示第一个参数是一个函数类型整体作为参数，如果省略括号，那么含义就变为两个整数参数了。

然而，很自然的会考虑，map当然不只能用于整数列表，也可以用于浮点数的列表或者字符串的列表。一般的，参数x的内容类型可以替换为一个类型参数a，这样我们得到map函数的更一般的形式。其类型表示为
```
map :: (a -> a) -> [a] -> [a]
```

考虑另一个例子：假如我们想判断一个列表中的整数是否是正数，我们可以写
```
map (>0) [1, 2, -3, 0, -1]
```
直觉上，上述表达式也应该是合法的，其返回值应该是
```
[true, true, false, false, false]
```
但此时map的第一个参数(>0)，接受一个整数作为参数，返回值则是bool类型值。
同时整个map函数最终的返回值也是一个bool值的列表而不是整数列表。
这意味着，函数参数f未必返回与参数相同的类型，f的类型可以是`a -> b`。
此时，map函数的类型为
```
map :: (a -> b) -> [a] -> [b]
```

这就是map函数的一般形式了，你答对了吗？

> 这里的map函数仍然不是最一般的形式，后面（第7章）将给出map函数更一般的形式。

</details>

foreach函数是map函数的一个简化。假如我们不关心f的返回值，仅仅只是将f应用到容器的每一个元素，就可以使用foreach函数。
在haskell这样的纯函数语言中，由于大部分函数式纯函数，因此foreach并没有什么作用。而在scala这样的混合范式语言中，foreach是一个经常使用的函数。

map/foreach函数从功能上与for循环几乎一致，然而它们比for循环的语义拥有更高层次的语义。
for循环指定的是执行的过程和顺序，而map/foreach函数指定的是对值的映射，前者是命令式的（怎么做），后者是声明式的（要做什么）。
这样一点微妙的差异，不仅使得整个表达更为简洁，而且留出了更多的优化空间：假如要将程序由单线程改为并行计算，使用map/foreach的程序根本不需要做任何变动；而使用for循环的程序，则需要一堆复杂的分析，确保循环中没有数据依赖才能做这样的并行化。
如果你了解一点大数据处理框架，你会发现这些框架提供的api，都是map函数这个语义层面的，而没有提供类似for循环这样更底层的语义。

## filter

filter函数也是一个常用的函数，它的功能是从列表中过滤出符合条件的元素。
仍然通过一个例子来了解：假设我们需要1到100内的所有偶数，我们首先可以定义一个函数，判断某个整数是否是偶数：
```
isEven x = x `mod` 2 == 0
```

> Note：Haskell中函数和运算符没有本质的区别，只不过函数默认为前缀表示，而运算符默认为中缀的。可以通过\`符号将函数转换为中缀运算符；也可以通过小括号将运算符转为前缀的函数。``3 `mod` 2``等同于`mod 3 2`；`(+) 3 4`等同于`3 + 4`。

然后将1到100的所有偶数过滤出来
```
filter isEven [1..100]
```

与map一样，filter接受一个函数和一个列表作为参数，并返回另一个列表作为结果。
不同的是，filter要求第一个参数f是一个返回bool类型的函数（这个有时参数也被称作“谓词”）。
然后filter将f应用到输入列表的每一个元素上，并把使结果为true的那些元素挑选出来组成新的list作为结果。

类似的，请思考filter函数的类型标注该怎么写？

<details>
<summary>点击查看答案</summary>

```
filter :: (a -> Bool) -> [a] -> [a]
```
</details>

## reduce / fold / scan

想像我们有一堆数字[5, 4, 3, 2, 1]，现在要求这些数字的总和，这种情况是map函数无能为力的。
因为map函数只能对单个元素做变换，而这里我们需要引入元素之间的运算。

一个最简单的方式是使用reduce函数：
```
>> reduce (+) [5, 4, 3, 2, 1]
15
```

> Note: 本例只是示意，Haskell中并未定义reduce函数。

与map和filter不同，reduce函数的第一个参数f不是一个单参数函数，而是一个双参数函数。
比如上述例子中的加法函数。
reduce函数首先将列表参数的前两个值（5和4）作为参数调用f，得到结果9。然后将这个结果（9）与列表的下一个值（3）作为参数，再次调用f，得到12。
以此类推，直到列表所有值都被处理后，将最后一次结果15作为返回值。

reduce的处理过程中，第一次调用f使用的是列表的前两个值。
有时我们想提供一个初始值，并要求f从这个初始值开始应用。
这种更一般的处理方法称为fold函数
```
>> fold (+) 100 [5, 4, 3, 2, 1]
115
```

fold函数是reduce的一种更通用的形式，它比reduce多出一个初始值（上例中的100）。
在执行运算时，初始值（100）和列表的首个值（5）先被应用到f（即加法）上，得到结果105，随后105再与列表第二个值运算，以此类推。

然而，同map函数一样，fold函数还可以再被一般化。fold的第一个参数f是一个二元函数，但我们并不一定要求f的两个参数拥有相同的类型。
举例来说，假如我们希望统计出一个元素为Bool的列表中，true元素的个数，我们可以这样写
```Haskell
>> fold (\init v -> if v then init + 1 else init) 0 [true, false, true, true, false]
3
```

> `\init v -> if v then init + 1 else init` 是Haskell中定义匿名函数的语法。`\`和`->`之间的是函数的参数，后面部分是函数体。
> 这个匿名函数接受两个参数init和v，如果v是true，那么返回值是init+1，否则返回init。
> 匿名函数在某些语言（Python，Java，C++等）中也被称为λ函数。

这里，匿名函数的两个参数init和v就是不同类型，init的类型为Integer，v的类型为Bool。

类似的，请思考，fold函数的完整类型是什么？

<details>
<summary>点击查看答案</summary>

```
fold :: (b -> a -> b) -> b -> [a] -> b
```
</details>
