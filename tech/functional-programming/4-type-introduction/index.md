---
title: "函数式编程笔记（四） —— 初窥类型系统"
# date: 2021-10-27T22:00:00+08:00
description: "我学习函数式编程的记录和思考"
draft: true
tags: ["Functional Programming"]
categories: ["Software"]
---

类型系统是一个编程语言必不可少的一部分。
通常来讲，类型系统是相对独立的部分，并不与编程范式绑定。
不过类型系统对函数式编程有很大的帮助，也有助于我们后面的讨论，所以在本篇中做一些初步介绍。

## 类型是什么

熟悉编程的人对类型的概念一定不陌生，C语言中就存在int/char/float等数据类型，而其他语言的类型比C语言更丰富。
然而汇编中却并没有数据类型的概念，所有的数据都不过是寄存器或者内存中的二进制串罢了。
这说明，类型这一概念对计算机系统来说并不是天然的，而是高级语言才引入的、有助于人类理解的东西。

那么类型到底是什么，有什么用，为什么要引入类型系统。我认为有以下几个方面理解：

1. 类型是数据编码的格式

计算机底层数据都是二进制的01串，而现实世界要处理的数据种类要丰富的多，包括数字、中英文、时间、地址、图像、视频等等。
为了在计算机系统里存储、传输和处理这些数据，必须将它们进行编码，即用2进制串来表示这些数据。

不同的数据自然有不同的编码方式。例如，对于整数的处理，我们可以将整数按一定的规则转换为2进制串，这样就得到一个编码方式，称为“补码”。
英文字母就要复杂一点了，因为必须对每个英文字母单独赋予一个编码，用某个数字来表示对应的字母，这样得到一个数字和字母的对应关系，称为“ASCII”码表。
类似的，对中文或其他复杂语言，有Unicode编码；对小数/实数，有“IEEE754”格式编码（通常称为浮点数）；等等。

对于计算机来说，所有这些数据都不过是01串而已。
具体某个01串究竟代表的是数字、英文字母还是中文字符，这需要额外的信息来做标识。
在编程语言中，数据（变量）的类型就是编码方式的标识：int类型代表数据是以“补码”编码的整数；double类型代表数据是“浮点数”编码的小数；char类型代表数据是以“ASCII”格式编码的英文字母……
有了类型信息，编译器就能据此做出正确的操作。这是类型系统的第一重含义。

2. 类型是编程语言的一种正确性保证

在现代编程语言中，类型往往被用做编程的辅助，提供某种程度的“正确性”保证。
例如`1.3 + "a"`这样的表达式，在大部分编程语言中是不合法的，因为将一个小数和一个字母相加，其含义是不明确的。
编译器通过类型检查，可以发现这类问题并给出错误提示。
因此可以说，类型系统提供了某些“正确性”的保证。

类型系统提供的正确性并不只局限于这类简单的问题，许多业务问题也可以通过类型系统提供保证。
举例来说，经常碰到的一个例子是某函数提供某些数据的分页查询。这样一个函数可能是这样的：
```
func querySomeData(page int, pageSize int) []Data {
    ……
}
```

然而，一些其他的函数可能要求参数不是页码（page），而是偏移量（offset，即从第几条数据开始）。
我就曾经碰到这样一个问题，调用方使用的时候误将偏移量当做页码传入了函数，造成返回数据不正确。

这样的小错误其实可以通过类型系统来避免。
Go语言中提供了一种语法，可以将一个类型包装为另一个类型。例如
```
type Page int
```
定义了一个新的类型`Page`，它的底层实现是`int`。它也可以使用`int`的一切操作（比如加减乘除），但是编译器仍然认为`Page`和`int`是两种不同的类型。
如果我们将`Page`和`Offset`分别定义为新的类型，而非使用原始的`int`类型，就可以避免这类错误。如下所示
```
type Page int
type Offset int

func querySomeData(page Page, pageSize int) []Data {
    ……
}
```
函数的页码参数不再是`int`类型，而是`Page`类型。这样当调用方误把offset当做page传入函数时，编译器会根据类型检查，向我们提示这个错误。

事实上，这种使用自定义类型来避免错误的方法，是现代编程中鼓励的一种实践，有人称之为“富类型”编程。

Haskell语言中也提供了类似的类型包装语法。我们可以使用`newtype`关键字将原始类型包装为新的类型。就像这样
```
newtype Page = Page { page :: Integer }
```

类型系统对程序正确性能够保证到什么程度，取决于很多方面，包括语言的类型设计和程序员所花费的时间精力。
在最强的情况下，类型系统可以像证明数学定理那样，证明一段程序的正确性！由此可见类型系统的强大之处。
当然这样所花费的成本也是高昂的：证明程序正确性所需要的代码量甚至远超程序本身。
在日常开发中，我们当然不必追求这样极致的正确性，但是类似上面页码的例子那样，通过简单的类型系统应用避免一些低级错误，仍然是很有价值的。

3. 类型可以定义为类型下所有值的集合

如何从数学的角度，形式化的定义类型这一概念呢？
一种方法是，类型可以定义为该类型的变量的所有合法值的集合。
比如，一个`int8`类型（8位有符号二进制整数），所有合法的值为
{-128, -127, -126, ..., -1, 0, 1, 2, ..., 127}。
那么`int8`类型就可以定义为包含这些值的集合。

这样的定义，可以自然延伸出一些其他的概念。
我们知道，集合之间可以有运算（比如交、并、差、积等）。那么类型是否也可以相互间做运算呢，这些运算是否有意义呢？
答案是“是的”，关于这部分内容，会在“代数数据类型”一章进一步讨论。

## 函数类型

前面我们提到，在函数式编程中，值和函数没有根本的分别。一个变量可以是一个值，也可以是一个函数。
对于值，我们可以定义出它们的类型，比如`1`的类型是`int`，`c`的类型是`char`等。
那么对于函数来说，它的类型是什么呢？

通常，我们认为函数的类型是由它的参数和返回值的类型所确定的。
例如add函数
```
func add(a int, b int) int {
    return a + b
}
```
它的类型就是`function (int, int) int`，含义为：add的类型是函数类型，它有两个`int`类型的参数和一个`int`类型的返回值。
不同的函数，只有它们的参数和返回值的个数以及对应位置上的类型都相同，我们才认为它们的类型是相同的。

## Haskell的类型表示法

Haskell的类型系统是比较完善的，它所使用的的类型表示法也是讨论类型系统时很常用的，因此在此介绍Haskell的类型表示方法，后文涉及类型系统时，都会使用这种表示方法。

在Haskell中，任意一个表达式都有类型，表达式的类型就是这个表达式所计算出来的值的类型。通常使用双冒号"::"来表示一个表达式的值。例如
```
1 :: Integer
3.1415 :: Double
'c' :: Char
1 + 3 :: Integer
```
分别表示`1`的类型是`Integer`，`c`的类型是`Char`等。

> Note: 和其他编程语言一样，Haskell定义了一些基本的数据类型。Integer是Haskell中表示所有整数的类型。

函数类型使用符号`->`来表示。比如`double`函数
```
double x = x * 2
```
其类型可以表示为
```
double :: Integer -> Integer
```
含义是，`double`是一个函数类型，它接受一个`Integer`类型的参数，返回一个`Integer`类型的返回值。

再考虑一个多参数函数`add x y = x + y`，你可能会猜测它的类型是
```
add :: (Integer, Integer) -> Integer
```
然而由于Haskell中的函数都是完全柯里化的，因此`add`函数的实际类型是

```
add :: Integer -> Integer -> Integer
```

还记得柯里化的确切含义吗？一个双参数函数，可以看做是一个单参数函数，其返回值是另一个单参数函数。
由于`->`操作符是向右结合的，因此`Integer -> Integer -> Integer`等价于`Integer -> (Integer -> Integer)`，它表示这个函数接受一个`Integer`类型的参数，返回一个`Integer -> Integer`类型的函数。
而这正是`add`函数柯里化后的类型！

关于函数类型，一个简单的理解是，最后一个`->`右边的是函数的返回值，其余的都是函数的参数。例如`a -> b -> c -> d`可以理解为一个三个参数的函数，其参数类型分别为`a`, `b`和`c`，返回值类型为`d`。

## 参数化类型

`double`函数表达的是将输入数字翻倍的含义，理论上它不仅可以用于整数（`Integer`）类型，也可以用于浮点数（`Float`）或其他数字类型。
要定义这种通用的`add`，它的类型签名就不能是`Integer -> Integer`，而需要是`a -> a`，其中`a`可以是任意数值类型（整数、浮点数、定点数、分数等）。

在Haskell中，小写字母`a, b, c, ...`通常用来表示一个未知的类型。
如果一个类型（包括函数类型）中包含了类型的未知量，那么这样的类型称为参数化类型（Parameterized Type）。
在Java、C++、Rust等语言中，参数化类型也被称为“泛型”(Generics)。实际上Java等语言引入泛型特性，大多是受到Haskell这类函数式语言的启发和影响。

Haskell天生支持参数化类型，因此在Haskell中写出通用的`double`函数是一件很自然的事情。
实际上，我们在ghci（Haskell的交互式环境）中定义`double`函数，并查看它的类型，得到的结果如下：

```
>> double x = 2 * x

>> :t double
double :: Num a => a -> a
```

上面例子中，`:t`命令用来查看一个表达式的类型，我们看到，`double`的类型为`Num a => a -> a`。

这里`=>`符号左边的内容表示类型约束。
Num和类型约束的确切含义将在后文“类型类”一章介绍，这里我们只需知道，`Num a`的含义是：`a`具体是什么类型无法确定（可能是整数，也可能是分数或浮点数），但是我们知道它是一个数值（Num）类型。

`=>`符号右边表示的是`double`的确切类型，即`a -> a`。这说明`double`是一个单参数、单返回值的函数，参数和返回值类型相同，都是`a`。

类似的，`add`函数的实际类型是
```
add :: Num a => a -> a -> a
```
